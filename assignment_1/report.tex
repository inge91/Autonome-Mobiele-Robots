\documentclass[a4paper, 20pt]{report}
\usepackage[english]{babel}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{subcaption}
\usepackage{placeins}

\author{Maarten de Jonge \\
    Inge Becht\\
Duncan ten Velthuis}
\date{\today}
\title{Autonome mobiele robots\\ 
Assignment 1}

\begin{document}
\maketitle

\begin{enumerate}
    \item For the differential drive robot:\\
        We want to find the $\xi_I$ at each $\Delta t$ interval.
        To do this we can use the formula:
        \begin{align*}
            \dot{\xi_I} = R(q)^{-1}J_1^{-1} *J_2*\varphi(t)
        \end{align*}
        where in the case of the differential drive:
        \begin{align*}
            R = \begin{bmatrix}
                cos(q) & sin(q) & 0           \\[0.3em]
                -sin(q) & cos(q)& 0           \\[0.3em]
                0 & 0 & 1\\
            \end{bmatrix}
            J_1 =
            \begin{bmatrix}
                sin(\alpha_1 + \beta_1)  &-cos(\alpha_1 + \beta_1) & (-l)cos(\beta_1)\\
                sin(\alpha_2 + \beta_2)  &-cos(\alpha_2 + \beta_2) & (-l)cos(\beta_2)\\
                cos(\alpha_1 + \beta_1) & sin(\alpha + \beta)    &   lsin(\beta) \\
            \end{bmatrix}
        \end{align*}
        \begin{align*}
            J2 = 
            \begin{bmatrix}
                r_1 & 0 & 0 \\
                0 & r_2 & 0 \\
                0 & 0 & 0\\
            \end{bmatrix},
            \varphi(t) = 
            \begin{bmatrix}
                \varphi_1(t) \\
                \varphi_2(t )\\ 
                0\\
            \end{bmatrix}
        \end{align*}
        The values inserted in $J_1$ are those of the constraints, with the
        first two rows being the rolling constraint for both wheels and the
        third column the sliding constraint for the robot.
        The value for $\alpha_1 = \frac{-\pi}{2}  $ and $\beta_1 =\pi$. For $\alpha_2
        = \frac{\pi}{2}$ and
        $\beta_2 = 0$. $J_2$ consists of the radii of
        the wheels on the diagonal.
        Filling in these values gives:
        \begin{align*}
            \dot{\xi_I} = R(q)^{-1} 
            \begin{bmatrix}
                0.5 & 0.5 & 0 \\
                0   & 0   & 1 \\
                \frac{1}{2l} & \frac{1}{2l} &0\\
            \end{bmatrix}
            \begin{bmatrix}
                r_1\varphi_1(t) \\
                r_2\varphi_2(t) \\
                0\\
            \end{bmatrix}
        \end{align*}

        Because with this formula only the velocity in the $x$, $y$ and $q$
        direction is given the new position (at time $t+\Delta t$) can be calculated with:
        \begin{align*}
            \xi^{t + \Delta t}_I = \xi^{t}_I + (\dot{\xi}^{t}_I *\Delta t )
        \end{align*}
    \item
    \begin{enumerate}{a} 
    \item Given without the constraints:
                \begin{align*}
                    \begin{bmatrix}
                        x\\
                        y\\
                        q\\
                    \end{bmatrix}^{t + \Delta t}
                    = 
                    \begin{bmatrix}
                        x\\
                        y\\
                        q\\
                    \end{bmatrix}^{t}
                    +( R(q)^{-1}  
                    \begin{bmatrix}
                        \frac{r_1\dot{\varphi_1}}{2} + \frac{r_2\dot{\varphi_2}}{2}\\
                        0\\
                        \frac{r_1\dot{\varphi_1}}{2l} + -\frac{r_2\dot{\varphi_2}}{2l}\\ 
                    \end{bmatrix}^{t}) * \Delta t
                \end{align*}
        \item
            $ \dot{w}(t) = \large{\frac{r_1\dot{\varphi_1}(t)}{2l} +
                -\frac{r_2\dot{\varphi_2}(t)}{2l}}$\\
                $ \dot{v}(t) = \frac{r_1\dot{\varphi_1}(t)}{2} +
                \frac{r_2\dot{\varphi_2}(t)}{2}$
        \end{enumerate}

    \item{
            This exercise was made in python. To control the robot we created 
            a movement API (see \tttext{movement.py})
            in which we distinguish between two possible motions; moving forward
            and rotating. For moving forward only motor speed and number of
            rotation degrees has to be specified by the user and this gets assigned to both
            wheels. For a rotation the robot rotates around point p between the
            wheels by moving
            one wheel forward and one wheel backward the same amount of degrees.
            Previously this rotation was around the other stationary wheel but
            this caused inaccuracy due to increased friction of the wheel's
            contact surface and it was for that reason decided to change this. 
            To construct a path for the robot to drive, a list of forward and rotation
            movements is specified with the desired speed and angle.

            For both movement types (rotation and straight ahead) we tested both using 
            brakes and not using breaks (by changing the brake argument in the run function). 
            Using breaks works much better than not using brakes for the
            odometrie model as then the specified number of turns are closer to
            the retrieved number of turns from the sensor data.

            We created two odometry models. The first model checked after every
            movement of the robot (so after each transition from moving straight
            ahead and rotating) if the specified amount of driven milimeters was the
            same as the actually specified amount of milimeters.  
        }
        

\end{enumerate}


\end{document}
